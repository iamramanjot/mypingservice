"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchError = exports.createFetch = void 0;
const log_1 = require("./log");
const defaultErrorFactory = async (response) => {
    if (response.headers.get('content-type')?.includes('application/json')) {
        const res = await response.json();
        return new FetchError({
            message: res?.message ?? res?.reason ?? JSON.stringify(res),
            httpCode: response.status
        });
    }
    else {
        const res = await response.text();
        return new FetchError({
            message: res,
            httpCode: response.status
        });
    }
};
const createFetch = async (url, options, errorFactory = defaultErrorFactory) => {
    try {
        (0, log_1.Log)().debug(`${options?.method}: ${url}`);
        const response = await fetch(url, { ...options });
        (0, log_1.Log)().debug(response.status + ': ' + response.statusText + ': ' + response.ok);
        if (!response.ok) {
            throw await errorFactory(response);
        }
        if (response.headers.get('content-type')?.includes('application/json')) {
            const res = await response.json();
            return res;
        }
        else {
            const res = await response.text();
            return res;
        }
    }
    catch (error) {
        if (error instanceof FetchError) {
            (0, log_1.Log)().debug(error.httpCode + ': ' + error.message);
            throw error;
        }
        throw new FetchError({ message: getErrorMessage(error) });
    }
};
exports.createFetch = createFetch;
const getErrorMessage = (error) => {
    if (error instanceof Error)
        return error.message;
    return JSON.stringify(error);
};
class FetchError extends Error {
    httpCode;
    constructor({ message, httpCode }) {
        super(message);
        this.httpCode = httpCode;
    }
}
exports.FetchError = FetchError;
//# sourceMappingURL=fetch.js.map