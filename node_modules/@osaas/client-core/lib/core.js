"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForInstanceReady = exports.valueOrSecret = exports.instanceValue = exports.getInstanceHealth = exports.getLogsForInstance = exports.getPortsForInstance = exports.listInstances = exports.getInstance = exports.removeInstance = exports.createInstance = exports.isValidInstanceName = exports.getService = void 0;
const errors_1 = require("./errors");
const fetch_1 = require("./fetch");
const log_1 = require("./log");
const delay = (ms) => new Promise((res) => setTimeout(res, ms));
async function getService(context, serviceId) {
    const serviceUrl = new URL(`https://catalog.svc.${context.getEnvironment()}.osaas.io/mysubscriptions`);
    const services = await (0, fetch_1.createFetch)(serviceUrl, {
        method: 'GET',
        headers: {
            'x-pat-jwt': `Bearer ${context.getPersonalAccessToken()}`,
            'Content-Type': 'application/json'
        }
    });
    const service = services.find((svc) => svc.serviceId === serviceId);
    if (!service) {
        throw new Error(`Service ${serviceId} not found in your subscriptions`);
    }
    return service;
}
exports.getService = getService;
const isValidInstanceName = (name) => {
    return /^[a-z0-9]+$/.test(name);
};
exports.isValidInstanceName = isValidInstanceName;
/**
 * @typedef ServiceInstance
 * @type object
 * @property {string} name - Service instance name
 * @property {string} url - Service instance URL
 * @property ... - Service specific properties
 */
/**
 * Create a new instance of a service in Open Source Cloud
 * @memberof module:@osaas/client-core
 * @param {Context} context - Open Source Cloud configuration context
 * @param {string} serviceId - Service identifier. The service identifier is {github-organization}-{github-repo}
 * @param {string} token - Service access token
 * @param {object} body - Service instance options. The options are service specific
 * @returns {ServiceInstance} - Service instance
 * @example
 * import { Context, createInstance } from '@osaas/client-core';
 *
 * const ctx = new Context();
 * const sat = await ctx.getServiceAccessToken('eyevinn-test-adserver');
 * const instance = await createInstance(ctx, 'eyevinn-test-adserver', sat, { name: 'my-instance' });
 * console.log(instance.url);
 */
async function createInstance(context, serviceId, token, body) {
    if (!(0, exports.isValidInstanceName)(body.name)) {
        throw new errors_1.InvalidName(body.name);
    }
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl);
    const instance = await (0, fetch_1.createFetch)(instanceUrl, {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
            'x-jwt': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });
    return instance;
}
exports.createInstance = createInstance;
/**
 * Remove an instance of a service in Open Source Cloud
 * @memberof module:@osaas/client-core
 * @param {Context} context - Open Source Cloud configuration context
 * @param {string} serviceId - The service identifier
 * @param {string} name - The name of the service instance to remove
 * @param {string} token - Service access token
 * @example
 * import { Context, removeInstance } from '@osaas/client-core';
 * const ctx = new Context();
 * const sat = await ctx.getServiceAccessToken('eyevinn-test-adserver');
 * await removeInstance(ctx, 'eyevinn-test-adserver', 'my-instance', sat);
 */
async function removeInstance(context, serviceId, name, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl + '/' + name);
    await (0, fetch_1.createFetch)(instanceUrl, {
        method: 'DELETE',
        headers: {
            'x-jwt': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });
}
exports.removeInstance = removeInstance;
/**
 * Retrieve an instance of a service in Open Source Cloud
 * @memberof module:@osaas/client-core
 * @param {Context} context - Open Source Cloud configuration context
 * @param {string} serviceId - The service identifier
 * @param {string} name - The name of the service instance to remove
 * @param {string} token - Service access token
 * @returns {ServiceInstance} - Service instance
 */
async function getInstance(context, serviceId, name, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl + '/' + name);
    try {
        const instance = await (0, fetch_1.createFetch)(instanceUrl, {
            method: 'GET',
            headers: {
                'x-jwt': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });
        return instance;
    }
    catch (err) {
        (0, log_1.Log)().debug(err);
        if (err instanceof fetch_1.FetchError && err.httpCode === 401) {
            throw new errors_1.UnauthorizedError();
        }
        else if (err instanceof fetch_1.FetchError && err.httpCode === 404) {
            return undefined;
        }
    }
    return undefined;
}
exports.getInstance = getInstance;
/**
 * List all instances of a service in Open Source Cloud
 * @memberof module:@osaas/client-core
 * @param {Context} context - Open Source Cloud configuration context
 * @param {string} serviceId - The service identifier
 * @param {string} token - Service access token
 * @returns {Array.<ServiceInstance>} - List of instances
 */
async function listInstances(context, serviceId, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl);
    return await (0, fetch_1.createFetch)(instanceUrl, {
        method: 'GET',
        headers: {
            'x-jwt': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });
}
exports.listInstances = listInstances;
/**
 * List all extra TCP ports routed to an instance in Open Source Cloud
 * @memberof module:@osaas/client-core
 * @param {Context} context - Open Source Cloud configuration context
 * @param {string} serviceId - The service identifier
 * @param {string} name - The name of the service instance
 * @param {string} token - Service access token
 * @returns {Array.<Port>} - List of ports
 */
async function getPortsForInstance(context, serviceId, name, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl);
    const portsUrl = new URL('https://' + instanceUrl.host + '/ports/' + name);
    return await (0, fetch_1.createFetch)(portsUrl, {
        method: 'GET',
        headers: {
            'x-jwt': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });
}
exports.getPortsForInstance = getPortsForInstance;
async function getLogsForInstance(context, serviceId, name, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl);
    const logsUrl = new URL('https://' + instanceUrl.host + '/logs/' + name);
    return await (0, fetch_1.createFetch)(logsUrl, {
        method: 'GET',
        headers: {
            'x-jwt': `Bearer ${token}`
        }
    });
}
exports.getLogsForInstance = getLogsForInstance;
async function getInstanceHealth(context, serviceId, name, token) {
    const service = await getService(context, serviceId);
    const instanceUrl = new URL(service.apiUrl);
    const healthUrl = new URL('/health/' + name, instanceUrl);
    const { status } = await (0, fetch_1.createFetch)(healthUrl, {
        method: 'GET',
        headers: {
            'x-jwt': `Bearer ${token}`
        }
    });
    return status;
}
exports.getInstanceHealth = getInstanceHealth;
function instanceValue(instance, key) {
    return instance[key].match(/^{{secrets}}/) ? '***' : instance[key];
}
exports.instanceValue = instanceValue;
function valueOrSecret(value) {
    return value.match(/^{{secrets}}/) ? '***' : value;
}
exports.valueOrSecret = valueOrSecret;
async function waitForInstanceReady(serviceId, name, ctx) {
    const serviceAccessToken = await ctx.getServiceAccessToken(serviceId);
    let instanceOk = false;
    while (!instanceOk) {
        await delay(1000);
        const status = await getInstanceHealth(ctx, serviceId, name, serviceAccessToken);
        if (status && status === 'running') {
            instanceOk = true;
        }
    }
}
exports.waitForInstanceReady = waitForInstanceReady;
//# sourceMappingURL=core.js.map